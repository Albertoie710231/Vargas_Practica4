/*
 * DMA.c
 *
 *  Created on: 3 may 2020
 *      Author: alber
 */

#include "DMA.h"
#include "Bits.h"
#include "MK64F12.h"
#include "DAC.h"
#include <stdint.h>
#include <stdio.h>

#define SIZE_ARRAY 256

#define NUM_STEPS (SIZE_ARRAY)
#define SYSTEM_CLOCK (21000000u)
#define DELAY (0.01F)

#define ARRAY_SIZE (16u)

#define DMA_CH0 (0x01u)
#define DMA_SOURCE_PDB (0x30u)

const uint16_t sin_signal[SIZE_ARRAY]=
{
		0x800,0x832,0x864,0x896,0x8C8,0x8FA,0x92C,0x95E,0x98F,0x9C0,0x9F1,0xA22,0xA52,0xA82,0xAB1,
		0xAE0,0xB0F,0xB3D,0xB6B,0xB98,0xBC5,0xBF1,0xC1C,0xC47,0xC71,0xC9A,0xCC3,0xCEB,0xD12,0xD39,
		0xD5F,0xD83,0xDA7,0xDCA,0xDED,0xE0E,0xE2E,0xE4E,0xE6C,0xE8A,0xEA6,0xEC1,0xEDC,0xEF5,0xF0D,
		0xF24,0xF3A,0xF4F,0xF63,0xF76,0xF87,0xF98,0xFA7,0xFB5,0xFC2,0xFCD,0xFD8,0xFE1,0xFE9,0xFF0,
		0xFF5,0xFF9,0xFFD,0xFFE,0xFFF,0xFFE,0xFFD,0xFF9,0xFF5,0xFF0,0xFE9,0xFE1,0xFD8,0xFCD,0xFC2,
		0xFB5,0xFA7,0xF98,0xF87,0xF76,0xF63,0xF4F,0xF3A,0xF24,0xF0D,0xEF5,0xEDC,0xEC1,0xEA6,0xE8A,
		0xE6C,0xE4E,0xE2E,0xE0E,0xDED,0xDCA,0xDA7,0xD83,0xD5F,0xD39,0xD12,0xCEB,0xCC3,0xC9A,0xC71,
		0xC47,0xC1C,0xBF1,0xBC5,0xB98,0xB6B,0xB3D,0xB0F,0xAE0,0xAB1,0xA82,0xA52,0xA22,0x9F1,0x9C0,
		0x98F,0x95E,0x92C,0x8FA,0x8C8,0x896,0x864,0x832,0x800,0x7CD,0x79B,0x769,0x737,0x705,0x6D3,
		0x6A1,0x670,0x63F,0x60E,0x5DD,0x5AD,0x57D,0x54E,0x51F,0x4F0,0x4C2,0x494,0x467,0x43A,0x40E,
		0x3E3,0x3B8,0x38E,0x365,0x33C,0x314,0x2ED,0x2C6,0x2A0,0x27C,0x258,0x235,0x212,0x1F1,0x1D1,
		0x1B1,0x193,0x175,0x159,0x13E,0x123,0x10A,0xF2,0xDB,0xC5,0xB0,0x9C,0x89,0x78,0x67,0x58,0x4A,
		0x3D,0x32,0x27,0x1E,0x16,0xF,0xA,0x6,0x2,0x1,0x0,0x1,0x2,0x6,0xA,0xF,0x16,0x1E,0x27,0x32,
		0x3D,0x4A,0x58,0x67,0x78,0x89,0x9C,0xB0,0xC5,0xDB,0xF2,0x10A,0x123,0x13E,0x159,0x175,0x193,
		0x1B1,0x1D1,0x1F1,0x212,0x235,0x258,0x27C,0x2A0,0x2C6,0x2ED,0x314,0x33C,0x365,0x38E,0x3B8,0x3E3,
		0x40E,0x43A,0x467,0x494,0x4C2,0x4F0,0x51F,0x54E,0x57D,0x5AD,0x5DD,0x60E,0x63F,0x670,0x6A1,0x6D3,
		0x705,0x737,0x769,0x79B,0x7CD

};



void DMA0_IRQHandler(void)
{
	uint8_t i;
	PDB0->SC &= ~PDB_SC_PDBIF(1);
	DMA0->INT = DMA_CH0;
	DMA0->CINT = 0;
}


void DMA_clock_gating(void)
{
	SIM->SCGC7 |= SIM_SCGC7_DMA_MASK;
	SIM->SCGC6 |= SIM_SCGC6_DMAMUX_MASK;
}


void DMA_init(void)
{

	DMAMUX->CHCFG[0] = 0;
	DMAMUX->CHCFG[0] = DMAMUX_CHCFG_ENBL_MASK | /*enables DMA MUX channel*/
					   DMAMUX_CHCFG_SOURCE(DMA_SOURCE_PDB);/*110000..PDB_Signal*/

	DMA0->ERQ = 0x01;//enables DMA0 request

	DMA0->TCD[0].SADDR = (uint32_t)(&sin_signal[0]);/*defines source data address*/
	DMA0->TCD[0].SOFF = 2;/*Source address signed offset;it is expressed in number of bytes*/
	DMA0->TCD[0].DADDR = (uint32_t)(&DAC0->DAT);/*defines destination data address*/
	DMA0->TCD[0].DOFF = 0;/*destination address signed offset;it is expressed in number of bytes*/

	/*CITER represents the number of minor loops that compose a major loop, every time a minor loop is completed CITTER is decremented by one.
	 * Once CITTER is 0 the DMA copy BITTER into CITTER and adjust SADDR and DADDR with the values specified in SLAST and DLAST_SGA respectively
	 *  SADDR  = SADDR + SLAST and DADDR + DLAST_SGA*/
	DMA0->TCD[0].CITER_ELINKNO = DMA_CITER_ELINKNO_CITER(NUM_STEPS);
	/* Once a major loop is completed, BITTER is copy to CITTER*/
	DMA0->TCD[0].BITER_ELINKNO = DMA_BITER_ELINKNO_BITER(NUM_STEPS);
	DMA0->TCD[0].NBYTES_MLNO = SIZE_ARRAY*2;/*byte number*/

	DMA0->TCD[0].ATTR = DMA_ATTR_SSIZE(1)|DMA_ATTR_DSIZE(1);/*8 bit transfer size, in order to transfer see Kinetis user manual*/
	DMA0->TCD[0].SLAST = -(SIZE_ARRAY*2);//restores the source address to the initial value, which is expressed in the amount of bytes to restore*/
	DMA0->TCD[0].DLAST_SGA = 0;/*restores the destination address to the initial value, which is expressed in the amount of bytes to restore*/
	DMA0->TCD[0].CSR = DMA_CSR_INTMAJOR_MASK;/*The end-of-major loop interrupt is enabled*/

}
